# OpenCV обзор

## 0. Зачем вам OpenCV и как он устроен

* **OpenCV = C/C++‑библиотека + Python‑обёртка**.
* Основа — матрица `cv::Mat` (в Python объект `numpy.ndarray`). По умолчанию канал‑порядок **BGR** и тип **uint8**.
* Большие подсистемы:

  1. `imgproc` — классическая обработка изображений;
  2. `videoio` — чтение/запись камер и файлов;
  3. `objdetect` — каскады Хаара, HOG;
  4. `dnn` — запуск пред‑обученных нейросетей;
  5. `cuda` — GPU‑ускоренные аналоги многих функций.

---

## 1. Работа с одним изображением

| Что хотим понять/сделать | Функция              | Что важно знать                                                                   |
| ------------------------ | -------------------- | --------------------------------------------------------------------------------- |
| Загрузить файл           | `imread`             | Флаг `IMREAD_GRAYSCALE` экономит память (1 канал).                                |
| Показать на экране       | `imshow` + `waitKey` | `waitKey` = 0 — «ждём клавишу», >0 — «кадр в цикле».                              |
| Сохранить                | `imwrite`            | Формат определяется расширением, можно передать параметры (качество JPEG и т.п.). |
| Узнать размер / тип      | `.shape`, `.dtype`   | `(h, w, c)` и тип чаще `uint8`.                                                   |

### 1.1. Геометрические операции

* **Изменить размер** → `resize` (интерполяции INTER\_NEAREST, INTER\_LINEAR, INTER\_AREA).
* **Обрезка ROI** → обычное NumPy‑срезание `img[y1:y2, x1:x2]`.
* **Поворот 90°/180°** → `rotate`; произвольный угол → `getRotationMatrix2D` + `warpAffine`.
* **Отразить** → `flip` (0 — по X, 1 — по Y, −1 — оба).

### 1.2. Переходы между цветовыми пространствами

* `cvtColor` с кодами `COLOR_BGR2RGB`, `…2GRAY`, `…2HSV`, `…2LAB`, `…2YCrCb`.

  * **RGB/BGR** — нативно для дисплея;
  * **HSV/HSL** — удобно отделять оттенок от яркости (сегментация);
  * **Lab** — эквивалентно восприятию человека, лучший выбор для кластеризации;
  * **YCrCb/YUV** — то, как хранится видео после компрессии.

---

## 2. «Нарисовать» на кадре (быстрая визуализация результатов)

| Примитив      | Функция     | Ключевые аргументы                                                  |
| ------------- | ----------- | ------------------------------------------------------------------- |
| Линия         | `line`      | точки P₁, P₂, цвет (B,G,R), толщина                                 |
| Прямоугольник | `rectangle` | левый‑верх, правый‑низ, цвет, толщина                               |
| Круг          | `circle`    | центр, радиус, цвет, толщина (−1 → заливка)                         |
| Текст         | `putText`   | строка, позиция базовой линии, шрифт `FONT_HERSHEY_*`, размер, цвет |

---

## 3. «Подготовка» изображения перед анализом

| Цель                               | Функция                                          | Что запомнить                      |
| ---------------------------------- | ------------------------------------------------ | ---------------------------------- |
| Убрать высокочастотный шум         | `GaussianBlur` (σ)                               | ставится первым шагом «перед всем» |
| Сохранить края, удалить соль‑перец | `medianBlur`                                     | отлично для бинаризации и Canny    |
| Сгладить / ускорить даунскейл      | `blur` / `boxFilter` / `resize` с INTER\_AREA    | самый дешёвый вариант              |
| Усилить контраст локально          | `equalizeHist` (серое) / `createCLAHE` (цветное) | «вытягивает» детали в тенях        |

---

## 4. Бинаризация ↔ основа большинства алгоритмов

* **Порог фиксированный** → `threshold` (`THRESH_BINARY`, `THRESH_OTSU`).
* **Адаптивный** → `adaptiveThreshold` (разный порог на разных окнах).
* Зачем? Бинарная маска — вход для `findContours`, морфологии и т.д.

---

## 5. Морфология — «лепим» бинарное изображение

| Операция  | Функция                        | Используем, чтобы…                        |
| --------- | ------------------------------ | ----------------------------------------- |
| Эрозия    | `erode`                        | удалить «усики», сузить объект            |
| Дилатация | `dilate`                       | закрыть дырки, увеличить объект           |
| Открытие  | `morphologyEx` с `MORPH_OPEN`  | убрать мелкие шумовые точки               |
| Закрытие  | `morphologyEx` с `MORPH_CLOSE` | залатать маленькие чёрные дыры            |
| Градиент  | `MORPH_GRADIENT`               | получить тонкий контур толщиной 1 пиксель |

---

## 6. Контуры: поиск, иерархия, метрики

| Шаг                   | Функция                                                            | Пояснение                                                                                                                    |
| --------------------- | ------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------- |
| Поиск                 | `findContours`                                                     | ⚙️ режим: `RETR_EXTERNAL`, `RETR_LIST`, `RETR_TREE`; ⚙️ метод: `CHAIN_APPROX_SIMPLE` (сжатие точек) или `CHAIN_APPROX_NONE`. |
| Рисовать              | `drawContours`                                                     | удобно для отладки.                                                                                                          |
| Площадь               | `contourArea`                                                      | пиксели²                                                                                                                     |
| Периметр              | `arcLength`                                                        | нужно для округлости, approxPolyDP…                                                                                          |
| Аппроксимация кривой  | `approxPolyDP`                                                     | многоугольники, распознавание форм.                                                                                          |
| Ограничивающие фигуры | `boundingRect`, `minEnclosingCircle`, `fitEllipse`, `minAreaRect`. |                                                                                                                              |
| Вложенность           | массив `hierarchy`                                                 | `[next, prev, first_child, parent]` для каждого контура.                                                                     |

**Бинаризация + морфология → контуры** — базовый пайплайн для измерения размеров деталей, подсчёта объектов, OCR‑предобработки.

---

## 7. Детекция границ

### 7.1. Градиентные фильтры (производная первого порядка)

| Фильтр  | Функция                              | Особенность                            |
| ------- | ------------------------------------ | -------------------------------------- |
| Sobel   | `Sobel`                              | классика; ядра 3×3 с весом 2 по центру |
| Prewitt | (нет явной, делают собственное ядро) | проще, чуть больше шумов               |
| Scharr  | `Scharr`                             | более точный градиент при 3×3          |

### 7.2. Вторые производные

* **Лапласиан (LoG)** → `Laplacian` (часто после `GaussianBlur`).
* **Difference of Gaussians (DoG)** → `GaussianBlur` два раза с σ₁, σ₂ и разница.

### 7.3. Алгоритм Canny (`Canny`)

1. Гауссово сглаживание.
2. Градиент Sobel → модуль + угол.
3. Non‑Maximum Suppression (оставить гребень).
4. Двойной порог `low`, `high`.
5. Гистерезис — соединить слабые пиксели, если рядом есть сильный.

---

## 8. Каскады Хаара (Viola–Jones) — классическая детекция объектов

| Слой                     | Что происходит                                                    |
| ------------------------ | ----------------------------------------------------------------- |
| Haar‑признаки            | «Белый − чёрный прямоугольник» → много гипотез.                   |
| Интегральное изображение | суммы считаются за O(1).                                          |
| AdaBoost                 | из миллиона признаков выбираем десятки «сильных».                 |
| Каскад — серия порогов   | каждое «окно» быстро отбрасывается, если не прошло ранние стадии. |

* Готовые XML‑файлы (`haarcascade_frontalface_default`, `…eye…`, `…smile…`).
* Основной вызов → `CascadeClassifier.detectMultiScale`.
* Параметры: `scaleFactor`, `minNeighbors`, `minSize`.
* Подходит для лиц, номеров, ладоней — там, где нужно «дёшево и быстро».

---

## 9. Работа с видео

| Задача                  | Функция                                | Детали                                                                                 |
| ----------------------- | -------------------------------------- | -------------------------------------------------------------------------------------- |
| Открыть камеру или файл | `VideoCapture`                         | свойства: `CAP_PROP_FRAME_WIDTH`, `…HEIGHT`, `…FPS`, `…FOURCC`.                        |
| Читать кадр             | `read`                                 | возвращает `ret`, `frame`; `ret==False` → конец.                                       |
| Запись                  | `VideoWriter`                          | требует 4 вещи: путь‑файл (контейнер), **FourCC** (`VideoWriter_fourcc`), FPS, размер. |
| FourCC примеры          | `'XVID'`, `'MJPG'`, `'avc1'`, `'H264'` | кодек ≠ контейнер; H.264 в `.avi` чаще не работает.                                    |
| Скриншот / кадр в файл  | `imwrite`                              | удобно для отладки.                                                                    |

**Памятка о дорожках:** контейнер MP4 может держать видео‑H.264 и аудио‑AAC, но `VideoWriter` пишет **только видео**; звук добавляют moviepy или прямым FFmpeg‑командой.

---

## 10. Производительность и практические советы

| Сцена                        | Что делает быстрее                                                |
| ---------------------------- | ----------------------------------------------------------------- |
| Один‑два тяжёлых фильтра     | `cv2.cuda_GaussianBlur`, `cv2.cuda_Canny` (если есть GPU).        |
| Серия лёгких операций на CPU | Объединяйте их в один граф NumPy → минимум переходов Python↔C.    |
| Много камер                  | Параллель — `cv2.VideoCapture` в потоках или GStreamer пайплайны. |
| I/O‑узкое место              | MJPG поток (читается быстро), H.264 — хранится компактно.         |

---

## Заключение: как связать всё вместе

1. **Подготовка изображения**
   `imread` → `cvtColor(BGR→GRAY)` → `GaussianBlur`
2. **Получение бинарной маски**
   `adaptiveThreshold` или `threshold` (+ `morphologyEx` для очистки)
3. **Извлечение формы**
   `findContours` (режим и метод под задачу)
4. **Аналитика**
   `contourArea`, `boundingRect`, `approxPolyDP`, `HuMoments`
5. **Быстрая визуализация**
   `drawContours`, `rectangle`, `putText`, `imshow`
6. **При необходимости детекция/отслеживание**
   *Простой* — `CascadeClassifier.detectMultiScale`
   *Точный* — модель в `dnn` или `onnxruntime`
7. **Работа с потоками**
   Реал‑тайм камера → `VideoCapture` → пункты 1‑5 → `VideoWriter`/стриминг

Запомните: **качественный результат = правильно подобранное пространство + адекватная пред‑обработка + корректные пороги**. OpenCV даёт кирпичи; этот конспект показывает, как их связать в стройный «дом» без пропусков в понимании.

---
---
---

# Как компьютер «видит» картинки и видео, и почему при записи нужен `VideoWriter_fourcc`

---

## 1.  Хранение статичных изображений

| Формат                          | Сжатие                    | Бит‑глубина / каналы              | Когда выбирать                                                 |
| ------------------------------- | ------------------------- | --------------------------------- | -------------------------------------------------------------- |
| **BMP, PPM, RAW**               | нет                       | любые                             | отладка, научные задачи, где важен абсолютно неизменный сигнал |
| **PNG**                         | без‑потерь, DEFLATE       | до 16 бит·канал + альфа           | графика, скриншоты, карты глубины                              |
| **TIFF**                        | опции LZW/JPEG2000        | произвольные каналы, 32‑бит float | медицина, фотограмметрия, проф. печать                         |
| **JPEG / JPEG‑XL / WebP‑lossy** | с потерями (DCT/аналог)   | 8–12 бит Y’CbCr                   | фото, где важен малый размер                                   |
| **EXR**                         | без‑потерь + полубайтовая | HDR (32‑бит float)                | VFX, 3D‑рендер                                                 |

*Файл* — это просто байтовый поток, в начале которого маленький **заголовок** сообщает: «я — PNG, размер 1920×1080, 8 бит на канал, цветовое пространство sRGB». Далее идут блоки данных, сжатые выбранным алгоритмом.
`cv2.imread` читает заголовок → выделяет буфер нужного размера → декодирует байты в матрицу пикселей **BGR uint8** (по умолчанию).

---

## 2.  Видео = контейнер + потоки

```
┌─────── AVI / MP4 / MKV / …  (контейнер) ────────┐
│   ┌─── «Video track» ──► кадр0, кадр1, … (кодек) │
│   └─── «Audio track» ──► сэмплы (кодек)          │
└──────────────────────────────────────────────────┘
```

* **Контейнер** (AVI, MP4, MKV, MOV…) — «папка»‑над‑файлом, которая хранит синхронизированные дорожки, тайм‑коды, субтитры, метаданные.
* **Кодек** — алгоритм сжатия/восстановления каждого потока: H.264, MPEG‑4 Part 2, HEVC, MJPEG…
* **Кадр** — матрица яркостей/цвета, поданная на вход кодека. Внутри кодек может хранить:

  * **Intra‑кадры** (полные, как JPEG)
  * **Inter‑кадры** (разница со ссылкой + векторы движения)

При чтении `cv2.VideoCapture` зовёт встроенный **FFmpeg**, который:
1. Парсит контейнер ➜ отдаёт сырые сжатые пакеты.
2. Декодирует кодеком ➜ выдаёт не‑сжатый кадр **BGR** в RAM.

---

## 3.  `cv2.VideoWriter` — мост между OpenCV и FFmpeg

```python
fourcc  = cv2.VideoWriter_fourcc(*'XVID')   # (1)
fps     = 20.0                              # (2)
size    = (640, 480)                        # (3)
out     = cv2.VideoWriter('out.avi', fourcc, fps, size, isColor=True)
```

| № | Параметр                 | Что означает                                                                                                                                                                                        |
| - | ------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1 | **`VideoWriter_fourcc`** | «FourCC» = **Four Character Code**. Это 32‑битное целое, в котором каждые 8 бит — ASCII‑символ. Например `'XVID'` = 0x58564944.<br>Код сообщается FFmpeg‑у: «используй кодек *Xvid/MPEG‑4 Part 2*». |
| 2 | **fps**                  | Сколько кадров в секунду записывать в контейнер. Должно совпадать с частотой, с которой вы передаёте кадры в `write`.                                                                               |
| 3 | **size**                 | Ширина×высота кадра. Большинство кодеков требуют, чтобы размер был чётным и, иногда, кратным 16.                                                                                                    |

Популярные FourCC коды:

| Контейнер | FourCC                | Кодек внутри  | Замечания                                    |
| --------- | --------------------- | ------------- | -------------------------------------------- |
| `.avi`    | `'XVID'`, `'DIVX'`    | MPEG‑4 Part 2 | совместимо со всеми плеерами                 |
| `.avi`    | `'MJPG'`              | Motion‑JPEG   | высокое качество, кадр = JPEG, файлы большие |
| `.mp4`    | `'mp4v'`              | MPEG‑4 Part 2 | для старых устройств                         |
| `.mp4`    | `'H264'` или `'avc1'` | H.264/AVC     | нужна сборка OpenCV с FFmpeg + libx264       |
| `.mkv`    | `'X264'`              | H.264         | гибкий контейнер; тот же кодек               |

> **Важно.** Сам контейнер (`.avi` или `.mp4`) определяется *по расширению файла*, а не по FourCC. Нельзя писать H.264 в AVI без дополнительных ухищрений.

---

## 4.  Поток работы при записи

1. **RGB/BGR кадр** приходит из камеры или рендерится в вашей программе.
2. OpenCV передаёт его кодеку → кодек сжимает → FFmpeg кладёт в контейнер.
3. При чтении всё в обратном порядке.

Если FPS в `VideoWriter` = 30, а вы случайно пишете кадры со скоростью 10 fps, видео будет «ускоренным»: контейнер будет считать, что каждые 33 мс должен выводиться новый кадр.

---

## 5.  Графические/видео‑буферы в памяти

* **Изображение** в RAM — непрерывный массив байтов.

  * Строка ⇄ Pix \* N‑каналов (у OpenCV — всегда **BGR** по 8 бит).
  * Выравнивание — обычно без «паддинга», stride = width × channels.
* **Видео‑кадр** перед компрессией часто конвертируется в **YUV 4:2:0** (субдискретизация цвета), потому что глаз менее чувствителен к цвету, чем к яркости.

---

## 6.  Где падают начинающие

| Ошибка                              | Причина                                           | Решение                                                                    |
| ----------------------------------- | ------------------------------------------------- | -------------------------------------------------------------------------- |
| Чёрный (пустой) файл                | Кодек не поддержан/ошибочный FourCC               | Проверьте `cv2.getBuildInformation()` → FFmpeg enabled?                    |
| Видео проигрывается быстро/медленно | Мismatch fps                                      | Выравнивайте частоту вызова `write` таймером/капчер‑fps.                   |
| Нет звука                           | `VideoWriter` работает **только с видео‑кадрами** | Склейте звук сторонним FFmpeg‑скриптом или используйте библиотеку moviepy. |
| Огромный размер файла               | MJPG или RAW‑AVI                                  | Выберите H.264 (`'avc1'`) или HEVC (`'HEVC'`) и контейнер MP4/MKV.         |

---

## 7.  Мини‑пример «правильной» записи MP4 (H.264)

```python
fourcc = cv2.VideoWriter_fourcc(*'avc1')  # H.264
fps    = 30
w, h   = 1280, 720

writer = cv2.VideoWriter('demo.mp4', fourcc, fps, (w, h))

cap = cv2.VideoCapture(0)                 # веб‑камера
cap.set(cv2.CAP_PROP_FRAME_WIDTH,  w)
cap.set(cv2.CAP_PROP_FRAME_HEIGHT, h)
cap.set(cv2.CAP_PROP_FPS,           fps)

while True:
    ret, frame = cap.read()
    if not ret: break

    writer.write(frame)                   # важна частота вызовов!

    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

cap.release()
writer.release()
```

---

### Краткие выводы

1. **Изображение** — это заголовок + сырая или сжатая матрица пикселей.
2. **Видео** = контейнер (AVI/MP4/…) + внутри один или несколько кодек‑потоков.
3. `VideoWriter_fourcc` даёт FFmpeg‑у 32‑битный «паспорт» кодека.
4. Указывайте согласованные `fps`, `size`, `fourcc`, иначе получите неожиданный результат.
5. За серьёзной сжатием / аудио делегируйте работу самому FFmpeg или moviepy.

Теперь вы точно понимаете, **почему** в примере записи требовались `fourcc`, `fps` и `size`, и как данные изображения и видео хранятся, читаются и записываются на компьютере.

---
---
---


#  Каскады Хаара

## 🟢 **Что такое каскады Хаара?**

**Каскады Хаара (Haar Cascades)** — это метод детекции объектов, который используется для быстрого и эффективного поиска заранее заданных объектов на изображении (например, лица, глаза, улыбки, машины и т.д.).

Метод основан на алгоритме Виолы-Джонса (**Viola-Jones**, 2001 г.), который является одним из самых первых и успешных подходов для детекции объектов в реальном времени.

---

## 🟢 **Как работают каскады Хаара? (алгоритм Виолы-Джонса)**

Алгоритм Виолы-Джонса и каскады Хаара состоят из нескольких ключевых идей и шагов:

### 🔹 **Шаг 1: Haar-подобные признаки (Haar-like features)**

Это простые признаки на изображении, вычисляемые как разность сумм пикселей в светлых и тёмных областях прямоугольников, которые напоминают базовые формы (горизонтальные, вертикальные линии, прямоугольники и т.п.):

```
+----------+----------+
|  светлое |  тёмное  |
+----------+----------+
```

Каждый признак:

* Прост в вычислении (разность интенсивностей пикселей).
* Хорошо выявляет перепады интенсивности, типичные для объектов (например, линия глаз или край лица).

Эти признаки вычисляются очень быстро благодаря специальной структуре данных — **интегральному изображению**.

---

### 🔹 **Шаг 2: Интегральное изображение**

Это особое представление изображения, где каждый пиксель — сумма интенсивностей всех пикселей выше и левее него. Благодаря этому сумму интенсивностей любой прямоугольной области можно вычислить за постоянное время **O(1)**:

```text
Integral(x,y) = sum(все пиксели выше и левее точки (x,y))
```

Это делает метод крайне быстрым и подходящим для обработки в реальном времени.

---

### 🔹 **Шаг 3: Каскадный классификатор**

Каскад — это серия последовательных классификаторов, которые проверяют объект на наличие признаков. Если на первых этапах объект не подходит, он быстро отбрасывается. Это обеспечивает очень высокую скорость:

```text
Изображение → Классификатор 1 → Классификатор 2 → ... → Классификатор N → найден объект!
```

* Если на каком-то этапе признаков недостаточно, область быстро отбрасывается.
* Только перспективные области проходят до конца каскада.

---

## 🟢 **Что такое предобученные каскады и зачем они нужны?**

**Предобученные каскады** — это уже готовые файлы классификаторов, обученные на большом количестве изображений для распознавания конкретных объектов (например, лиц, глаз, улыбок).

OpenCV предоставляет набор уже обученных каскадов для типичных задач:

* Лица (`haarcascade_frontalface_default.xml`)
* Профиль лица (`haarcascade_profileface.xml`)
* Глаза (`haarcascade_eye.xml`)
* Улыбки (`haarcascade_smile.xml`)
* Верхняя часть тела (`haarcascade_upperbody.xml`)

Вы можете сразу использовать их в своих задачах без дополнительного обучения.

---

## 🟢 **Как использовать каскады в OpenCV? (на примере лиц)**

### 📌 **Шаг 1. Загрузка каскада**

```python
import cv2

# Загрузка готового каскада Хаара для лиц
face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')
```

### 📌 **Шаг 2. Загрузка и обработка изображения**

```python
img = cv2.imread('photo.jpg')
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
```

### 📌 **Шаг 3. Детекция лиц**

```python
faces = face_cascade.detectMultiScale(gray, scaleFactor=1.1, minNeighbors=5)
```

Значения параметров:

* **`scaleFactor`** — как сильно уменьшается изображение на каждом следующем этапе. Значение около **1.05–1.3**.
* **`minNeighbors`** — сколько соседних прямоугольников нужно, чтобы считать детекцию надёжной. Чем выше, тем меньше ложных срабатываний, но можно пропустить лица. Обычно **3–6**.

### 📌 **Шаг 4. Отрисовка результатов**

```python
for (x, y, w, h) in faces:
    cv2.rectangle(img, (x, y), (x+w, y+h), (255,0,0), 2)

cv2.imwrite('faces_detected.png', img)
```

---

## 🟢 **Когда лучше применять каскады Хаара?**

**Преимущества:**

* Очень высокая скорость работы.
* Простота использования.
* Нет необходимости в GPU, работает на слабых устройствах.

**Недостатки:**

* Не всегда стабильно в сложных условиях освещения.
* Не устойчиво к поворотам объекта (нужно несколько каскадов под разные углы).
* Уступает по точности современным нейросетевым методам (например, YOLO, SSD, Faster R-CNN).

**Где применять?**

* Когда требуется высокая скорость.
* Когда простота и низкие вычислительные затраты важнее точности.
* В задачах быстрой и грубой оценки (например, детекция лиц в реальном времени для веб-камер).

---

## 🟢 **Можно ли обучить свой каскад?**

Да, OpenCV предоставляет инструменты (`opencv_traincascade`) для обучения собственных каскадов. Для этого нужно:

* Собрать много изображений объекта (**положительные примеры**).
* Собрать изображения фона без объекта (**отрицательные примеры**).
* Запустить обучение (занимает время, от нескольких часов до суток).

Это полезно, если вы хотите детектировать специфические объекты, которых нет в стандартных каскадах.

---

## 🏅 **Итоги:**

Каскады Хаара — это:

* Быстрый и простой метод детекции объектов.
* Хорошо подходит для задач, где нужна скорость и простота реализации.
* Идеален для предварительной оценки объектов в реальном времени (например, лица в камерах видеонаблюдения).

Современные задачи с высокой точностью и устойчивостью лучше решать нейросетевыми моделями, но каскады Хаара до сих пор остаются эффективным, простым и востребованным инструментом для многих реальных проектов.


---
---
---


# Предобработка изображения, избавление от деффектов.

## 1. Стандартные беды изображения — как выглядят и почему появляются

| №     | Симптом (что вы видите)                                                           | Типичная причина                                |
| ----- | --------------------------------------------------------------------------------- | ----------------------------------------------- |
| **A** | На однородных участках одиночные белые/чёрные пиксели («соль‑перец»)              | битовый шум сенсора, спонтанные ошибки передачи |
| **B** | Лёгкое «зерно» по всему кадру; если увеличить — мелкие точечки                    | гауссов шум (ISO↑, слабое освещение)            |
| **C** | Изображение тёмное / выгоревшее; деталей мало, гистограмма «собрана» влево/вправо | неверная экспозиция, резкая сцена‑контрастность |
| **D** | Часть кадра ярче/темнее (пятна света, виньетка)                                   | неравномерное освещение, оптика                 |
| **E** | Лестничные края после сильного даунскейла                                         | алиасинг, nearest‑neighbor ресайз               |
| **F** | Блоки 8×8, «квадратики»                                                           | сильное JPEG‑сжатие                             |
| **G** | Резкие блики, засвеченные точки                                                   | зеркальные поверхности, вспышка                 |
| **H** | Изображение смазано по направлению движения                                       | длинная выдержка, движение камеры/объекта       |

---

## 2. Как быстро диагностировать проблему

| Приём                                             | Что смотреть                                 | Что покажет                                                 |
| ------------------------------------------------- | -------------------------------------------- | ----------------------------------------------------------- |
| **Визуально 100 %**                               | Увеличить 2–4× в просмотрщике                | «Соль‑перец» и зерно видны сразу                            |
| **Гистограмма** (`calcHist`)                      | равномерность распределения                  | кучка слева → недоэкспонировано, справа → переэкспонировано |
| **Оценка шума** (`Laplacian`→var)                 | var ≈ 0 → кадр размыт, ↗︎ var → шум/резкость | полезно отличить шум от motion blur                         |
| **Карта освещённости** (`blur` радиус ≈ ширина/3) | медленно меняющийся фон                      | пятна неравномерного света                                  |

---

## 3. Таблица «симптом → лекарство» (фильтр и почему он работает)

| Симптом                    | Лекарство (функция)                                               | Почему помогает                                                              | На что обратить внимание                                                      |
| -------------------------- | ----------------------------------------------------------------- | ---------------------------------------------------------------------------- | ----------------------------------------------------------------------------- |
| **A «соль‑перец»**         | `medianBlur(ksize)`                                               | медиана заменяет пиксель на средний из окна, выбрасывая одиночные выбросы    | ksize нечётный 3–7; чем больше — тем сильнее размывает мелкие детали          |
| **B гауссов шум**          | `GaussianBlur(ksize, σ)` или `bilateralFilter`                    | Гаусс усредняет c весами‑колоколами; bilateral сглаживает, но сохраняет края | σ=1–2 px перед Canny/contours; bilateral дорогой, но лучший для тонких границ |
| **C низкий контраст**      | `equalizeHist` (серое) / `createCLAHE` (цвет)                     | растягивает гистограмму; CLAHE делает это локально => не жжёт светлое        | для цвета переводите в LAB и равняйте канал L                                 |
| **D пятна освещения**      | `divide(img, blur(img, big_kernel))` («центровка фона») + `CLAHE` | сначала убираем медленную подсветку, потом тянем детали                      | размер гаусса ≈ ¼–½ от размера кадра                                          |
| **E лесенка после resize** | `resize(..., INTER_AREA)`                                         | AREA — усреднение, убирает высокие частоты, подавляет алиасинг               | если ↓ > 4×, делайте поэтапно или сразу в AREA                                |
| **F JPEG‑блоки**           | лёгкий `GaussianBlur` или `fastNlMeansDenoisingColored`           | сглаживают переходы между 8×8                                                | NLM (Non‑Local Means) сохраняет детали, но медленнее                          |
| **G блики**                | `inpaint` + маска бликов                                          | заполняет пересвеченные области текстурой из окружения                       | сделать маску — порог по яркости или цвету                                    |
| **H motion blur**          | `deblur` (нет в OpenCV, внешние пакеты) или `Wiener` фильтр       | нужно знать длину и угол сдвига; задача сложная                              | проще переснять или использовать короткую выдержку                            |

---

## 4. Типичный порядок предобработки в проекте

1. **Дешёвое сглаживание от шума**
   `GaussianBlur` σ≈1 или `medianBlur(3)`
2. **Коррекция освещения/контраста**
   *Если нужно* → `createCLAHE` на канал L, либо «деление на размытый фон».
3. **Приведение к нужному размеру**
   `resize` (INTER\_AREA ↓, INTER\_LINEAR ↑).
4. **Цветовое пространство** – задача‑зависимо
   `cvtColor` → HSV/LAB/GRAY.
5. **Бинаризация или градиенты**
   `adaptiveThreshold`, `Canny`, `Sobel`.
6. **Морфология**
   `morphologyEx` OPEN/CLOSE для чистки маски.
7. **Контуры / детекторы**
   `findContours`, `CascadeClassifier`, `dnn`.

> **Правило:** «грязь и контраст» фиксируем раньше, «размер и цвет» — после.

---

## 5. Как убедиться, что фильтр действительно помог

| Метод                               | Что делаем                                        | Что считаем                                                           |
| ----------------------------------- | ------------------------------------------------- | --------------------------------------------------------------------- |
| Визуальное сравнение                | `imshow` до/после, быстро меняя окна              | субъективно ищем: шум ↓, детали ↑                                     |
| Показ градиентов                    | `Sobel`→`magnitude`                               | если цель — контуры → кол‑во ненулевых пикселей после порога должно ↑ |
| PSNR / SSIM (есть в OpenCV contrib) | сравниваем с «эталоном», если он есть             | PSNR > 30 дБ обычно «без заметной деградации»                         |
| Распознаваемость                    | запустить свой алгоритм (детектор, классификатор) | метрика (accuracy, IoU) должна расти                                  |

---

## 6. Быстрый чек‑лист «что брать первым делом»

| Сцена                                    | Вероятная беда                  | Начните с                                     |
| ---------------------------------------- | ------------------------------- | --------------------------------------------- |
| Камера в лаборатории, хорошее освещение  | лёгкое ISO‑зерно                | `GaussianBlur(1.3)`                           |
| Уличная web‑камера ночью                 | соль‑перец + сильный шум        | `medianBlur(3)` → `GaussianBlur(σ=1.5)`       |
| Сканированный документ                   | неровная подсветка + жёлтый фон | деление на размытый фон → `adaptiveThreshold` |
| Микроскоп                                | виньетка + низкий контраст      | `equalizeHist` или `CLAHE`                    |
| Фото телефона, нужно детектировать текст | разный масштаб, шум мало        | `resize` → `bilateralFilter` → `Canny`        |

---

### Главное, что стоит запомнить

1. **Сначала найдите проблему** (глазами, гистограммой).
2. **Используйте минимальный фильтр**, который лечит именно её — не надо «всех подряд».
3. **Проверяйте эффект** — число контуров, качество сегментации, метриками вашей задачи.

Так вы перестанете гадать и будете осознанно включать предобработку в любой конвейер компьютерного зрения.


---
---
---

# Морфологические операции в openCV

## 1. Что такое математическая морфология

Это **набор операций над бинарными (или серыми) изображениями, основанный на теории множеств**.

* Изображение ⇒ множество точек: $A\subset \mathbb{Z}^2$.
* **Структурный элемент** (kernel) — маленькое множество $B$ (обычно 3 × 3, 5 × 5), которое мы «катаем» по изображению и делаем логические проверки вида «входит / пересекается / пусто?».

Морфология отвечает на два основных вопроса:

1. **Где истинный объект, а где шум?**
2. **Как изменить форму объекта (расширить, сузить, «снять оболочку»), не испортив топологию?**

---

## 2. Базовые операции

| Операция                                       | Определение множеством                     | Интуиция «на пальцах»                                                                                                                             |
| ---------------------------------------------- | ------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Эрозия** $A\ominus B$                        | $\{x\mid B_x \subseteq A\}$                | «Пикаем» B над каждым пикселем; если B целиком помещается внутрь объекта → оставляем центр. Объект **усыхает**, тонкие «усики» исчезают.          |
| **Дилатация** $A\oplus B$                      | $\{x\mid (B̂)_x \cap A \neq \varnothing\}$ | Сдвигаем B̂ (зеркальный) и проверяем пересечение. Как будто «мелочи» наружу заливаются краской → объект **растёт**, дырки внутри стенки сужаются. |
| **Открытие** $A\circ B=(A\ominus B)\oplus B$   | эрозия + дилатация                         | Сначала сузили → убрали шум, потом вернули размер. Итог: **исчезают объекты меньше B**, а большие сохраняют форму.                                |
| **Закрытие** $A\bullet B=(A\oplus B)\ominus B$ | дилатация + эрозия                         | Сначала расширили → заполнили дыры, потом вернули размер. Итог: **зарастают мелкие отверстия** и стыкуются близкие пиксели.                       |
| **Морф. градиент** $(A\oplus B)-(A\ominus B)$  | разница дилатации и эрозии                 | Получаем **рамку толщиной ≈ ½ B** вдоль границы; удобно как «тонкий контур».                                                                      |

Практически в OpenCV:

* `cv2.erode`, `cv2.dilate` + аргумент `kernel`.
* `cv2.morphologyEx` с флагами `MORPH_OPEN`, `MORPH_CLOSE`, `MORPH_GRADIENT`.

---

## 3. Как выбрать структурный элемент

| Форма ядра                  | Когда берут                                                            |
| --------------------------- | ---------------------------------------------------------------------- |
| **Крест** (крест‑3×3)       | удалять вертикальные/горизонтальные «шумы» без затрагивания диагоналей |
| **Квадрат / прямоугольник** | универсальный вариант; быстро на CPU/GPU                               |
| **Диск / эллипс**           | сохраняет «округлость» объектов (клетки, круговые детали)              |
| **Пользовательский**        | хит‑или‑промах, шаблоны‑буквы, скелетизация                            |

**Размер** ядра → физический порог. B шириной k пикселей *уничтожит* детали ≤ k (при открытии) и *затянет* дырки ≤ k (при закрытии).

---

## 4. Типичные задачи и рецепты

| Цель                                           | Что делаем                                                                  | Почему морфология, а не фильтр                                           |
| ---------------------------------------------- | --------------------------------------------------------------------------- | ------------------------------------------------------------------------ |
| Убрать соль‑перец, но сохранить края           | `opening` с диском 3 px                                                     | медиана тоже удалит, но может смазать границу; открытие возвращает форму |
| Склеить текст, у которого порвались штрихи     | `closing` с крестом 3×3                                                     | дилатация «мостит» разрывы, эрозия убирает утолщение                     |
| Заполнить мелкие отверстия внутри маски        | `closing` размер в 2–4 px                                                   | быстро и детерминировано                                                 |
| Сделать тонкий «скелет» / получить ось объекта | `morphological thinning` (в OpenCV нет прямо, но через `ximgproc.thinning`) | лучше, чем Canny: скелет внутри объекта                                  |
| Подготовить sure‑fg/bg для watershed           | **Эрозия** (foreground) и **дилатация** (background)                        | требование алгоритма: семена внутри и снаружи                            |
| Быстро получить контур без Canny               | `morph_gradient`                                                            | 1 операция, независимо от порогов                                        |

---

## 5. Когда морфология **не** поможет

| Проблема                                                      | Почему                                                                                         |
| ------------------------------------------------------------- | ---------------------------------------------------------------------------------------------- |
| Гауссов «зернистый» шум по всему изображению                  | Требуются линейные фильтры (Gaussian/Bilateral); морфология зависит от формы, не от статистики |
| Сильный размытый (motion blur) край                           | Дилатация/эрозия лишь изменят форму, не восстановят резкость                                   |
| Цветовой шум в RGB                                            | Сначала переводим в HSV/LAB и делаем морфологию на **маске** (binarized hue/segmentation)      |
| Если объектов надо *разъединить* по касательной (тонкая щель) | Морфология только соединяет/отъедает. Нужен раскрашивание расстоянием, watershed, k‑means      |

---

## 6. Практическая методика выбора параметров

1. **Создайте бинарную маску,** даже если цель — серое изображение.
2. **Визуально найдите минимальную нежелательную деталь** (точка, дырка, разрыв). Измерьте её диаметр d.
3. **Поставьте ядро $B$ чуть больше d.** Эффект будет «проходит/не проходит».
4. **Итерации вместо большого ядра.** Дилатация с маленьким ядром N раз ≈ дилатация большим ядром. Иногда проще контролировать.
5. **Оцените метрикой:** например, количество связанных компонент (`connectedComponentsWithStats`) должно ↓, площадь главного объекта ≈ стабильна.

---

## 7. Расширенные операции (когда базовых мало)

| Операция                                          | Идея / пример использования                                                |
| ------------------------------------------------- | -------------------------------------------------------------------------- |
| **Top‑hat** (`MORPH_TOPHAT`)                      | $A - (A\circ B)$ → выделяет **мелкие светлые детали** (царапины, трафарет) |
| **Black‑hat** (`MORPH_BLACKHAT`)                  | $(A\bullet B) - A$ → **мелкие тёмные детали**                              |
| **Hit‑or‑miss** (`morphologyEx`, `MORPH_HITMISS`) | поиск конкретных маленьких шаблонов (точный пиксельный паттерн)            |
| **Distance Transform** + порог                    | позволяет превратить объект в «ядро» для watershed или найти центры фигур  |
| **Thinning / Skeletonize** (модуль `ximgproc`)    | получение однопиксельного скелета — полезно в OCR, PCB‑трассеровке         |

---

## 8. Краткое «если увидели … — делайте …»

| Вид проблемы в маске                                    | Действие                                                   |
| ------------------------------------------------------- | ---------------------------------------------------------- |
| Беспорядочная россыпь белых точек                       | `opening` маленьким диском                                 |
| В маске дырявые объекты                                 | `closing`; при крупных отверстиях — два прохода            |
| Нужно «удалить» волосы/кабели от основного тела         | `erode` N раз, а если надо восстановить — `dilate` N‑k раз |
| Хотите ровный контур без лишнего — но пиксель в пиксель | `morph_gradient` → `dilate` 1 px → XOR с оригиналом        |

---

### Главное, что стоит запомнить

* **Морфология = контроль формы**. Она идеальна там, где важно, «пролезает ли» элемент данного размера.
* **Структурный элемент — ваш параметр качества.** Подбирая форму и размер, можно точно настроить, какие детали сохраняем/убиваем.
* **Всегда работайте на бинарных или чётко сегментированных масках.** На сером/цвете линейные фильтры эффективнее, морфология — для пост‑правки формы.

Используйте эти правила как чек‑лист, и ваши бинарные изображения перестанут быть «лохматыми» и непредсказуемыми.


---
---
---


# Сегментация ROI и «умные» маски — как получить *именно тот* объект, а не окрестные пиксели

*ROI (Region of Interest) = маска пикселей, которые мы принимаем за «главных». Чем чище маска → тем точнее метрики, быстрее сеть и меньше ложных триггеров.*

## 1 Зачем вообще сегментировать

| Задача                        | Что даёт ROI                                 | Где встречается                                      |
| ----------------------------- | -------------------------------------------- | ---------------------------------------------------- |
| Как‑нибудь отделить фон       | экономим вычисления, убираем шум             | препроцесс детекции, отслеживание руки на веб‑камере |
| Разделить «слипшиеся» объекты | считаем штуки, не взяв два вместе            | таблетки на конвейере, эритроциты под микроскопом    |
| Маска для обучающей разметки  | питаем в нейросеть только «валидные» пиксели | semi‑supervised learning, data‑augmentation          |
| Пер‑пиксельная метрика        | IoU / Dice требуют точной границы            | медицинская КТ, спутниковые снимки                   |

---

## 2 Карта методов: от «дешево» к «умно»

| Класс метода                         | Когда брать                             | Что вызывает в OpenCV                                   |
| ------------------------------------ | --------------------------------------- | ------------------------------------------------------- |
| **Глобальный цвет / k‑means**        | фон почти однородный (BG≈1‑2 цветов)    | `kmeans`, `inRange`, `meanShift`                        |
| **Фоновая вычитка (BG subtract)**    | стационарная камера, движущийся объект  | `createBackgroundSubtractorMOG2`, `KNN`, `apply`        |
| **Watershed + маркеры**              | много «слипшихся» деталей               | `distanceTransform` → `threshold` → `watershed`         |
| **GrabCut (Graph‑Cut)**              | один «основной» объект, фон неоднороден | `grabCut` (mask/rect, iter=5–10)                        |
| **Суперпиксели SLIC / SEEDS**        | нужно минимально‑перегруженную маску    | `ximgproc.createSuperpixelSLIC`, `iterate`, `getLabels` |
| **Semantic / instance segmentation** | класс‑маски, многокласс                 | `dnn.readNet` + пред‑обученный DeepLab/Mask‑RCNN        |
| **Interactive (scribbles/points)**   | пользователь уточняет границу           | комбинация GrabCut + камнеморфология                    |

---

## 3 Ключевые алгоритмы и типовой pipeline

### 1) **Вычитка фона** (живое видео)

```text
cap → apply() → морфология OPEN/CLOSE → маска движущегося тела
```

*Плюсы*: real‑time, одно‑кнопочно.
*Минусы*: дрожание камеры и тени дают фантомы ⇒ используем `detectShadows=False` + морф. фильтры.

### 2) **Watershed для разделения слипшихся**

```python
# (а) бинаризация → (b) distTransform → (c) threshold → (d) erode
markers = cv2.connectedComponents(...)
cv2.watershed(imgColor, markers)
```

*Правило*: чем качественнее «семена» (sure‑fg и sure‑bg), тем меньше пере‑/недосегментации.
Маркер −1 → итоговый контур; остальные номера — отдельные объекты.

### 3) **GrabCut (граф‑каты)**

*Вызов*: `cv2.grabCut(img, maskOrRect, None, bgdModel, fgdModel, 5, mode)`
*Режимы*:

* `GC_INIT_RECT` – прямоугольник вокруг объекта;
* `GC_INIT_WITH_MASK` – тонкое «пометь фон/объект» кистью.

Внутри: GMM‑построение FG/BG → минимизация энергии граф‑катом.
*Фишки*: после 1‑го вызова можно до‑рисовать маску (усиливать `GC_FGD` / `GC_BGD`) и запустить снова.

### 4) **Суперпиксели SLIC**

```python
spx = cv2.ximgproc.createSuperpixelSLIC(img, region_size=20, ruler=10.0)
spx.iterate(10)
labels = spx.getLabels()
```

*Идея*: склеить пиксели в ≈ ровные «пятна», сократив 1e6 пикселей до 2e3 кластеров.
Дальше — обычный k‑NN / простая метка классов по среднему цвету внутри суперпикселя.

---

## 4 Типовые ошибки и как лечить

| Ошибка                                      | Диагностика                                      | Исправление                                                                |
| ------------------------------------------- | ------------------------------------------------ | -------------------------------------------------------------------------- |
| Watershed режет объект на части             | много «островов» с одним цветом на distTransform | увеличьте kernel, сгладьте DT (`GaussianBlur`) или поднимите порог sure‑fg |
| GrabCut остаётся шумной каймой              | GMM плохо разделил FG/BG                         | 2–3 итерации, передайте вручную `mask` с усиленными метками                |
| Фоновая вычитка даёт фантомы                | колышутся листья, авто‑экспозиция                | `history` ↑, `varThreshold` ↑, включить/выключить тени                     |
| Суперпиксельные границы «рвут» мелкий текст | region\_size слишком велик                       | уменьшите размер или переключитесь на SEEDS (сохраняет края)               |

---

## 5 Post‑processing: делаем маску «production‑ready»

1. **Морфология** – `opening` убирает одиночный шум, `closing` запаивает дырки.
2. **Удаление мелких компонент** – `connectedComponentsWithStats` + порог по площади.
3. **Сглаживание границы** – `cv2.GaussianBlur(mask, (0,0), σ=1)` и `threshold` обратно.
4. **CRF / Conditional Random Field** (доп. библиотека `pydensecrf`) – подбирает границу по цвету, особенно после нейросети.

---

## 6 Метрики качества сегментации

| Метрика             | Формула                                   | Когда использовать                 |    |         |     |                            |     |                                           |
| ------------------- | ----------------------------------------- | ---------------------------------- | -- | ------- | --- | -------------------------- | --- | ----------------------------------------- |
| **IoU / Jaccard**   | ( \frac{                                  | M\cap G                            | }{ | M\cup G | } ) | общая оценка, значения 0–1 |     |                                           |
| **Dice / F1‑score** | ( \frac{2                                 | M\cap G                            | }{ | M       | +   | G                          | } ) | медицина (чувствит. к маленьким объектам) |
| **Pixel accuracy**  | $\frac{\Sigma TP}{\Sigma\text{пикселей}}$ | классическая классификация         |    |         |     |                            |     |                                           |
| **Boundary F1**     | F‑score только по краевой зоне 2 px       | важны именно края (нанолитография) |    |         |     |                            |     |                                           |

`M` — ваша маска, `G` — GT‑разметка. Считаем в NumPy или `scikit-image.metrics`.

---

## 7 Когда какой метод выгоднее

| Сцена                                     | Лучший выбор                      | Почему                                           |
| ----------------------------------------- | --------------------------------- | ------------------------------------------------ |
| Статичная камера <br/>+ бегущий человек   | MOG2 BG subtract                  | фон выучивается, real‑time                       |
| Фрукт + темноватый конвейер (фон сложный) | GrabCut прямоугольником           | один крупный объект, оператор выделил рамку      |
| Таблетки, лежащие в кучке                 | Watershed (DT + morph)            | разделит касающиеся круглые объекты              |
| Фото‑портрет с неоднородным фоном         | SLIC → кластер цвета → морфология | аккуратно обходится без ручной разметки          |
| Робот‑пылесос с RGB‑D камерой             | Семантическая сеть (DeepLab)      | нужно отличать пол, ковер, стены — много классов |

---

**Итого**: добавив в конвейер один‑два «умных» алгоритма сегментации и правильную до‑/после‑обработку, вы получите **чёткую, компактную, пригодную для дальнейших шагов** ROI‑маску практически для любой прикладной задачи — от десктоп‑софта до edge‑AI устройства в промышленном цеху.

---
---
---

# Детекторы и дескрипторы признаков — «узнаём» одно и то же место на разных кадрах

*Признак* (feature) — это пара **(keypoint + descriptor)**.

* Детектор → говорит, **где** в изображении «интересные» точки.
* Дескриптор → квантует локальный патч вокруг точки в компактный вектор, чтобы две одинаковые точки «узнавали» друг друга после поворота, масштаба, освещения.

Без устойчивых признаков невозможны панорамы, SLAM, 3‑D‑реконструкция, AR‑метки и «умные» трекеры.

---

## 1 Классическая трёхшаговая схема

```
I → детектор(keypoints) → дескриптор(vectors) → матчинг(соответствия)
```

1. **Keypoints** — \~1 000 штук (углы, пятна, блобы).
2. **Descriptor** — 32…128 чисел на каждую точку.
3. **Matcher** сравнивает векторы: быстрый Hamming (бинарные) или L2 (вещественные).
4. **Геометрическая проверка** (RANSAC + homography/essential) отбрасывает ложные пары.

---

## 2 Детекторы (где искать)

| Детектор       | Функция OpenCV                        | Физическая идея                      | +                                 | −                             |
| -------------- | ------------------------------------- | ------------------------------------ | --------------------------------- | ----------------------------- |
| **Harris**     | `cornerHarris`, `GFTTDetector_create` | максимум второй производной — «угол» | прост, CPU                        | нет масштаба                  |
| **FAST**       | `FastFeatureDetector_create`          | эвристика 16‑пиксельного круга       | очень быстрый, идеален для видео  | неустойчив к масштабу         |
| **DoG / SIFT** | `SIFT_create`                         | разница гауссов на пирамиде          | точность, масштаб/поворот‑инвар.  |  медленнее, раньше патент     |
| **SURF**       | `xfeatures2d.SURF_create`             | взвеш. дериваваты loG                | быстрее SIFT, robust              | non‑free, убран из pip OpenCV |
| **ORB**        | `ORB_create` (FAST + ориентация)      | FAST + BRIEF + LSH                   | real‑time, патент‑free            | масштаб ≈ ±1.5х               |
| **BRISK**      | `BRISK_create`                        | детект‑BRISK + pattern               | scale‑/rotation‑OK, бинарный      | чуть медленнее ORB            |
| **AKAZE**      | `AKAZE_create`                        | нелин. диффузия (MSD)                | хорошо на текстурах, scale‑robust | меньше paper‑проверок         |
| **KAZE**       | `KAZE_create`                         | как AKAZE, но float                  | максимальная точность             | медленнее, не бинарный        |
| **Blob (LoG)** | `SimpleBlobDetector_create`           | максимумы Laplacian                  | круглые пятна                     | только blob‑сцены             |

---

## 3 Дескрипторы (как описать)

| Тип        | Примеры OpenCV                                       | Длина вектора | Сколько весит (бит) | Расстояние    |
| ---------- | ---------------------------------------------------- | ------------- | ------------------- | ------------- |
| **Float**  | SIFT, SURF, KAZE                                     | 128 float     | 512 байт            | L2 (Euclid)   |
| **Binary** | ORB (32 байт), BRISK (64), AKAZE (61), FREAK, BEBLID | 256–512 бит   | 32–64 байт          | Hamming (XOR) |
| **Гибрид** | LATCH, DAISY                                         | зависит       |                     |               |

*Зачем бинарные?* — где нужен real‑time или MCU: битовые XOR проходят за \~1 тактовый цикл.

---

## 4 Матчинг и фильтрация

| Шаг               | Функция                                         | Что делает                                |
| ----------------- | ----------------------------------------------- | ----------------------------------------- |
| Поиск k‑ближайших | `BFMatcher` (Hamming/L2), `FlannBasedMatcher`   | строит пары (или 2 лучших для ratio‑test) |
| Лоу‑Ratio Test    | ручная проверка `d0 < 0.75 d1`                  | отсеивает амбигуйтные матчи              |
| Взаимная проверка | `crossCheck=True`                               | пара должна совпадать в обе стороны       |
| Геометрия         | `findHomography`, `findEssentialMat` + `RANSAC` | оставляет inliers, выдаёт матрицу H/E     |
| Отрисовка         | `drawMatches`, `drawMatchesKnn`                 | визуальный дебаг                          |

**Инлайн‑коэфф.** = inliers / matches → >0.5 считаем хорошую сцепку кадров.

---

## 5 Практические наборы «что взять»

| Задача                  | Детектор+дескриптор | Matcher         | Комментарий                        |
| ----------------------- | ------------------- | --------------- | ---------------------------------- |
| Реал‑тайм AR на Android | ORB (1000 pts)      | BF(Hamming)     | 15‑30 fps на ARM                   |
| Сшивка фото‑панорамы    | SIFT                | FLANN(L2)       | точность важнее, время не критично |
| Одометрия квадрокоптера | FAST+BRIEF или ORB  | BF + RANSAC     | лёгкие кадры 640×480               |
| 3‑D рендер агрегация    | AKAZE               | BF/Hamming      | устойчив к scale, шуму             |
| FPGA/MCU скан‑линии     | BRISK               | собственный XOR | чисто бинарный стек                |

---

## 6 Тонкости и грабли

* **Цвет не нужен** — почти все алгоритмы работают на GRAY.
* **Too many keypoints = медленно** → берём топ‑N по response (`kp.response`) или задаём `nfeatures`.
* **Повторяемость важнее количества** — лучше 200 устойчивых точек, чем 2000 случайных.
* **Перспективная сцена ≠ планарная** — homography валидна, только если объект плоский или наблюдение ≈ –45 °.
* **Репетитивные текстуры** — «кирпичная стена» даёт ложные матчи → поднимите ratio‑threshold до 0.6 и используйте RANSAC.
* **Разная экспозиция** — ORB/BRISK устойчивы хуже, SIFT/AKAZE лучше.
* **Патенты**: после 2020 SIFT свободен, SURF всё ещё non‑free.

---

## 7 Связка с другими блоками конспекта

* **Суперпиксели** → можно искать ключ‑точки *только* в центре каждого SLIC‑кластерa — экономия 5×.
* **Оптический поток** → инициализируйте LK‑трек с детектора GFTT + фрейм‑skip N.
* **DNN** → современные *SuperPoint*, *DISK*, *LoFTR* кидаются в `cv2.dnn`, но требуют GPU; классические признаки остаются fallback‑ом CPU‑edge.

---

## .8 Мини‑чек‑лист «я хочу матчить два кадра»

1. `cvtColor` → GRAY.
2. `detector.detectAndCompute()` → kp, desc.
3. `matcher.knnMatch(desc1, desc2, k=2)`
4. Lowe‑ratio 0.75, `good` список.
5. `findHomography(pts1, pts2, RANSAC, 3.0)` → H, mask.
6. Ищем `mask.sum() / len(good)` > 0.5 → «успех».

---

## 9 Куда движется будущее

* **Deep‑Local Features** (Transformers, GNN) вытесняют SIFT в high‑end Z‑SLAM.
* **Binary‑Neural** дескрипторы (SuperGlue‑Lite) обещают real‑time на ARM + NPU.
* Но **классические ORB/SIFT** останутся must‑know: их легко встроить, лицензии чистые, работают офлайн без GPU.

---

**Запомнить**: *детектор* выбирает «что матчить», *дескриптор* — «как сравнить», *matcher + RANSAC* — «кто действительно пара».  Эти три кирпича, грамотно настроенные, превращают разрозненные картинки в согласованный 3‑D‑мир или бесшовную панораму.

---
---
---


# Hough‑преобразования и поиск параметрических фигур — «ловим» линии, окружности и даже эллипсы, когда контуры рвутся

*Смысл*: преобразуем задачу «точки на плоскости» → «пики в параметрическом пространстве».  Если в изображении есть множество точек, лежащих на одной геометрической кривой, то в Hough‑пространстве они дадут **общий максимум**; достаточно порогнуть аккумулятор, и фигура найдена.

---

## 1 Классика: прямая в пространстве (ρ, θ)

| Формула               | Объяснение                                                             |
| --------------------- | ---------------------------------------------------------------------- |
| ρ = x cos θ + y sin θ | нормальная форма прямой; θ∈\[0, π), ρ — расстояние до начала координат |

**Алгоритм** `HoughLines`:

1. Бинарный край (`Canny`) → набор белых точек.
2. Для каждой точки генерируем синусоиду в (ρ, θ) и инкрементируем аккумулятор.
3. Локальные максимумы > threshold → прямые.

*Параметры*:

* `rho_res` — дискретизация ρ (1‑2 px).
* `theta_res` — шаг угла (π/180 ≈ 1°).
* `threshold` — минимум голосов.

---

## 2 HoughLinesP — «Probabilistic» (отрезки вместо бесконечных прямых)

* Идея: берём не все точки, а случайные, и сразу вычисляем границы отрезка с помощью группировки последовательных пикселей.
* Плюсы: **быстрее ×10**, сразу даёт (x₁,y₁,x₂,y₂).
* Важно: `minLineLength`, `maxLineGap` подбирают под масштаб (px).

---

## 3 Окружности — HoughCircles

| Параметр                 | Что делает                                                           |
| ------------------------ | -------------------------------------------------------------------- |
| `dp`                     | масштаб аккумулятора: 1 → ρ‑размер = size, 2 → в 2 раз меньше памяти |
| `minDist`                | минимум между центрами → защищает от кучи совпадающих окружностей    |
| `param1`                 | верхний порог Canny                                                  |
| `param2`                 | минимум голосов в аккумуляторе (чем ниже → чувствительней)           |
| `minRadius`, `maxRadius` | диапазон поиска                                                      |

Внутри: 3‑D акум. ( x, y, r ) → сужают `dp` и радиус, чтобы не взрывать память.

---

## 4 Эллипсы и другие кривые

* **HoughEllipses** — в OpenCV «out‑of‑tree», есть в contrib (Python нет) → часто заменяют контур + `fitEllipse`.
* **Парабола / ломаная** — индивидуальные кастомы или RANSAC‑подгонка.
* Много параметров = экспоненциальная память → применяют *Randomized Hough Transform* (RHT).

---

## 5 Типовой pipeline «ищем линии/круги»

```
gray → GaussianBlur → Canny → morphology (optional) → HoughLinesP / HoughCircles
```

*Сначала чистим шум*, иначе аккумулятор переполняется фантомами.  Для окружностей почти всегда нужен `medianBlur` — убирает соль‑перец вдоль границы.

---

## 6 Частые грабли и лекарства

| Симптом                                 | Причина                              | Что делать                                                  |
| --------------------------------------- | ------------------------------------ | ----------------------------------------------------------- |
| Слишком много линий‑фантомов            | низкий `threshold` или шумовые точки | поднять `threshold`; ужесточить Canny и `minLineLength`     |
| Линии рвутся                            | `maxLineGap` слишком мал             | увеличить gap, либо перейти к HoughLines + группировка      |
| Кружки «дублируются» разными радиусами  | низкий `minDist`                     | ставьте ≥ 0.9 × мин радиуса                                 |
| Не ловит бледные/частично стёртые круги | порвавшаяся граница даёт мало точек  | `param2`↓ на 20 %, `GaussianBlur` σ↑, или попытаться RHT    |
| Ошибка из‑за масштаба                   | сильно разные r                      | вызывайте HoughCircles дважды с разными диапазонами радиуса |

---

## 7 Скорость и память

| Трюк                                                                   | Экономия                                    |
| ---------------------------------------------------------------------- | ------------------------------------------- |
| Downscale изображение ×½ перед Hough, потом масштабируйте результаты   | 4× быстрее, круги > 10 px ещё видны         |
| Ограничьте `theta` диапазоном (например, дорожная разметка ≈ 0° ± 10°) | меньше акк. ячейки                          |
| Применяйте `mask` (ROI)                                                | вычисления только там, где ожидается фигура |
| Используйте CUDA‑вариант (OpenCV `cuda::Hough*`)                       | real‑time на Jetson                         |

---

## 8 Когда Hough — лучшее решение, а когда нет

| Сцена                                    | Hough?                        | Объяснение                                      |
| ---------------------------------------- | ----------------------------- | ----------------------------------------------- |
| Дорожные полосы, PCB‑дорожки             | **Да** (HoughLinesP)          | параллельные, контрастные линии                 |
| Подсчёт круглых таблеток на белом фоне   | **Да** (HoughCircles)         | размер известен, фон чистый                     |
| Эллиптические клетки, тонкая мембрана    | `fitEllipse` по контурy лучше | HoughEllipses дорог и шумоустойчив хуже         |
| Неровные границы (рукописный контур)     | **Нет**                       | Скелет + RDP / сплайн‑аппрокс.                  |
| Слабоконтрастные, частично скрытые линии | **Нет**                       | Дип‑лайн‑детекторы (HED, LSD) справляются лучше |


---

**Коротко**: Hough‑преобразование — это «голосование» точек за параметры кривой; один порог в аккумуляторе — и у вас координаты линий или кругов даже на разорванных, частично скрытых границах.  Понимая выбор параметров, область применения и ограничения по шуму/масштабу, можно за несколько миллисекунд вытянуть дорогу из камеры‑дрона или посчитать все отверстия в листовом металле.
